<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kubernetes on Ibiza</title>
    <link>http://kimmj.github.io/tags/kubernetes/</link>
    <description>Recent content in kubernetes on Ibiza</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 May 2020 01:46:22 +0900</lastBuildDate>
    
	<atom:link href="http://kimmj.github.io/tags/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Overview</title>
      <link>http://kimmj.github.io/kubernetes/installation/overview/</link>
      <pubDate>Tue, 14 Jan 2020 01:42:53 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/installation/overview/</guid>
      <description>저의 vm으로 구성한 클러스터를 설명드리고자 합니다.
 Cloud Provider: Kubernetes on-prem (4 VMs)  1 for master (4GB Mem, 2 CPU) 3 for worker (each 8GM Mem, 4 CPU)   Kubernetes 1.17.0 Storage Class: Ceph OS: Ubuntu 18.04.2 Server Internal Network: VirtualBox Host-Only Ethernet Adapter (192.168.x.0/24) External Network: Bridge to adapter (192.168.y.0/24)  한번에 쳐야하는 명령어가 많기 때문에, tmux를 사용해서 여러개의 pane을 생성하고 각각에 대해 ssh로 접속하였습니다.</description>
    </item>
    
    <item>
      <title>Controllers Overview</title>
      <link>http://kimmj.github.io/kubernetes/concepts/controllers-overview/</link>
      <pubDate>Thu, 30 Jan 2020 18:26:04 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/concepts/controllers-overview/</guid>
      <description>Contents 이 포스트에서는 Kubernetes의 Controller들에 대해서 알아보도록 하겠습니다. 가장 작은 단위인 Container부터, 상위 개념인 Deployment, StatefulSet까지 다루어 보도록 하겠습니다.
 Containers Pods ReplicaSets Deployments StatefulSets  Monolithic vs. Microservice 우선 Monolithic과 Microservice에 대해서 짚고 넘어가도록 하겠습니다.
Monolithic의 개념은 하나의 큰 어플리케이션을 말합니다. 여러 사람이 개발을 하고 나서 하나의 큰 패키지로 빌드하고 이를 배포하죠. 간단한 서비스라면 문제가 발생하지는 않겠지만, 점점 코드의 수가 늘어나고 거대해질 수록 문제점이 생깁니다. 예를 들면 빌드시간이 오래걸린다던지, scale-out을 하기 힘들다던지 하는 문제가 있겠네요.</description>
    </item>
    
    <item>
      <title>10 Kubernetes the Hard Way</title>
      <link>http://kimmj.github.io/kubernetes/cka-study/10-kubernetes-the-hard-way/</link>
      <pubDate>Tue, 12 May 2020 01:46:22 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/cka-study/10-kubernetes-the-hard-way/</guid>
      <description>Design a Kubernetes Cluster  Purpose  Education  Minikube Single node cluster with kubeadm/GCP/AWS   Development &amp;amp; Testing  Multi-node cluster with a Single Master and Multiple workers Setup using kubeadm tool or quick provision on GCP or AWS or AKS   Hosting Production Applications  HA Multi node cluster with multiple master nodes 최대 5000노드 클러스터 내에 최대 약 150000 파드 최대 300000개의 컨테이너 노드당 최대 약 100개의 파드     Cloud or OnPrem  on-prem에는 kubeadm을 사용하자.</description>
    </item>
    
    <item>
      <title>09 Networking</title>
      <link>http://kimmj.github.io/kubernetes/cka-study/09-networking/</link>
      <pubDate>Mon, 04 May 2020 18:12:04 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/cka-study/09-networking/</guid>
      <description>Switching Routing  Switching  컴퓨터 두대를 스위치를 통해 연결하는 방법. 연결된 스위치의 인터페이스에 ip를 할당한다. 동일한 네트워크로만 트래픽을 보내준다.   Routing  라우터는 스위치로 연결된 두 네트워크 대역을 연결해준다. 각 네트워크 대역에 대해서 아이피를 동시에 가지고 있다.   Gateway  어떤 아이피 대역에 대해서 어떤 라우터를 통해서 가게 할지 결정하는 것 외부 인터넷과 연결하고 싶다면 먼저 인터넷을 라우터에 연결하고, 이 곳으로 route 설정을 하면 된다. default gateway는 Destination=0.</description>
    </item>
    
    <item>
      <title>08 Storage</title>
      <link>http://kimmj.github.io/kubernetes/cka-study/08-storage/</link>
      <pubDate>Mon, 04 May 2020 02:34:12 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/cka-study/08-storage/</guid>
      <description>Introduction to Docker Storage  docker에는 두가지 컨셉의 stroage가 있다.  storage drivers volume drivers    Storage in Docker  file system  /var/lib/docker에 docker가 사용하는 파일들이 있다.   docker는 layered architecture라서 caching을 사용할 수 있다. 이렇게 해서 이미지를 실행시키면 해당 이미지에 사용된 layer들은 Read Only이다. 컨테이너 상에서 실행하는 것들은 container layer로, Read Write이다. Read Only상의 파일을 수정하면 도커는 자동으로 이를 복사해서 수정한다. 여기서 영구적으로 보관하고 싶은 것들이 있다면, volume을 사용해야한다.</description>
    </item>
    
    <item>
      <title>07 Security</title>
      <link>http://kimmj.github.io/kubernetes/cka-study/07-security/</link>
      <pubDate>Sat, 25 Apr 2020 20:26:41 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/cka-study/07-security/</guid>
      <description>Kubernetes Security Primitives  host와 cluster 자체의 security  당연히 host는 그 자체로 안전해야하고, root access는 disable 되어야 하며 password based authentication은 disabled되고 SSH key based authentication만 가능해야 한다. Kubernetes를 실행시키고 있는 호스트에 대한 physical, virtual infrastructure에 대한 보안도 필요하다.   쿠버네티스와 관련된 security  kube-apiserver는 모든것을 하는 주체가 되기 때문에 이곳에 대한 보안부터 챙겨야 한다. Who can access? / What can they do? API 서버에 누가 접근을 할 수 있게 할 것인가?</description>
    </item>
    
    <item>
      <title>06 Cluster Maintenance</title>
      <link>http://kimmj.github.io/kubernetes/cka-study/06-cluster-maintenance/</link>
      <pubDate>Fri, 24 Apr 2020 13:09:30 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/cka-study/06-cluster-maintenance/</guid>
      <description>OS Upgrades  Node가 Down된 상태에서 5분이 지나면 pod는 terminate가 된다.  Dead로 간주   ReplicaSet으로 관리되면 다른곳에 파드를 띄워준다. kube-controller-manager에 pod-eviction-timeout이 기본적으로 5분이 설정되어 있다. 다시 online으로 오게되면 blank node로 뜨게 된다. ReplicaSet으로 관리되지 않았던 파드는 삭제되고 재생성되지 않는다. 따라서 kubectl drain node를 통해 파드를 이주시키고 cordon을 통해 스케줄되지 않도록 한다. 그 다음에 노드를 down시키고 살리면 된다. 산 뒤에도 이전에 처리한 cordon이 남아있게 되는데 이를 삭제하기 위해선 kubectl uncordon을 해야한다.</description>
    </item>
    
    <item>
      <title>05 Application Lifecycle Management</title>
      <link>http://kimmj.github.io/kubernetes/cka-study/05-application-lifecycle-management/</link>
      <pubDate>Sun, 19 Apr 2020 17:02:09 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/cka-study/05-application-lifecycle-management/</guid>
      <description>Rolling Updates and Rollbacks  kubectl rollout status deployment/myapp-deployment로 롤아웃 상태 확인 가능 kubectl rollout history deployment/myapp-deployment로 히스토리 확인 가능 Recreate: old를 모두 죽인 뒤 new를 생성 Rolling Update: old를 하나씩 죽이고 하나씩 new를 생성 kubectl set image deployment myapp-deployment nginx=nginx:1.9.1로 이미지 수정 가능 StrategyType이 Recreate면 old의 replica가 모두 0으로 줄고난 뒤 new의 replica를 늘린다. 반면 RollingUpdate일 경우 old를 하나씩 죽이고 new를 하나씩 늘린다. Rollback을 할때는 반대로 동작한다. kubectl run을 통해 파드를 생성하면 deployment가 생성된다.</description>
    </item>
    
    <item>
      <title>04 Logging and Monitoring</title>
      <link>http://kimmj.github.io/kubernetes/cka-study/04-logging-and-monitoring/</link>
      <pubDate>Sat, 18 Apr 2020 21:47:08 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/cka-study/04-logging-and-monitoring/</guid>
      <description>Monitor Cluster Componets  쿠버네티스에서 자체 제공하는 것은 없으나 다음과 같은 것들이 있다.  Metrics Server Prometheus Elastic Stack DataDog Dynatrace   metric server는 각 쿠버네티스의 노드와 파드의 메트릭을 모아서 메모리에 저장한다. metric server는 유일한 in-memory monitoring solution이다.  데이터를 저장하지 않아서 이전 자료를 보지 못한다.   kubelet은 cAdvisor를 포함한다.  파드로부터 퍼포먼스 메트릭을 수집하여 메트릭 서버로 전송한다.   metric server가 설치되면 kubectl top node, kubectl top pods를 사용하여 메트릭을 볼 수 있다.</description>
    </item>
    
    <item>
      <title>03 Scheduling</title>
      <link>http://kimmj.github.io/kubernetes/cka-study/03-scheduling/</link>
      <pubDate>Wed, 15 Apr 2020 18:55:03 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/cka-study/03-scheduling/</guid>
      <description>Manual Scheduling  how scheduling works  podSpec에 nodeName 필드를 채워넣으면 해당 노드로 파드가 뜬다. default로는 비워져있음. 스케줄링은 알고리즘에 의해 파드를 띄울 노드를 선택하고 나면 nodeName 필드를 채운다. 스케줄러가 없으면 파드가 계속해서 pending 상태에 있게 된다. 따라서 스케줄러가 없으면 단순히 nodeName을 채우면 될 것이다. runtime에 nodeName을 변경할 수 있는데, 이는 kind=Binding object를 binding API로 POST 요청을 보내는 방식으로 가능하다. binding definition에 target.name=&amp;lt;NodeName&amp;gt;으로 설정하면 된다. 이를 JSON 형식으로 보내면 된다.  따라서 yaml을 json으로 변경해야한다.</description>
    </item>
    
    <item>
      <title>02 Core Concepts</title>
      <link>http://kimmj.github.io/kubernetes/cka-study/02-core-concepts/</link>
      <pubDate>Tue, 14 Apr 2020 00:42:25 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/cka-study/02-core-concepts/</guid>
      <description>Controller는 Kubernetes의 brain과 같다.  ReplicaSets  Pod가 죽게 되면 사용자가 접근을 할 수 없게 된다. 따라서 여러개의 파드를 띄워 하나가 죽어도 나머지가 동작하도록 해야한다. Replication Controller는 여러개의 파드를 띄울 수 있도록 도와준다. 이를 High Availability라고 한다. 하나의 파드만 관리한다고 해서 쓸모없는게 아니라 이는 하나가 죽으면 다시 하나를 실행시키는 방식으로 동작한다. 로드가 늘어나면 파드를 늘릴 수 있다. Replica Controller와 Replica Set은 비슷하지만 다르다.  Replica Controller는 Replica Set으로 대체되었다.   Replica Controller  apiVersion=v1 spec.</description>
    </item>
    
    <item>
      <title>CKA(Certified Kubernetes Administrator) 시험 준비</title>
      <link>http://kimmj.github.io/ibiza/cka-prepare/</link>
      <pubDate>Mon, 16 Mar 2020 21:23:52 +0900</pubDate>
      
      <guid>http://kimmj.github.io/ibiza/cka-prepare/</guid>
      <description>작년 6월경 처음 쿠버네티스를 접할때부터 알게되었던 인증시험. 계속해서 취득해보겠다고 다짐은 했지만 미루다보니 어느덧 해가 지나 3월이 되었다. 올해 목표로 삼은 것이기도 하니 빨리 준비해서 취득해야겠다.
스터디  https://github.com/cncf/curriculum 참조 https://kubernetes.io/ 공부  유용한 글  https://github.com/kelseyhightower/kubernetes-the-hard-way  gcp를 통한 쿠버네티스 구성   https://coffeewhale.com/k8s/network/2019/04/19/k8s-network-01/ 시리즈  목표  시험: 4월 26일 이전까지 -&amp;gt; 계속 밀려서 7월 마지막날까지로 변경 응시료: $300  </description>
    </item>
    
    <item>
      <title>[번역] 쿠버네티스에서의 Port, TargetPort, NodePort</title>
      <link>http://kimmj.github.io/kubernetes/port-targetport-nodeport-in-kubernetes/</link>
      <pubDate>Sun, 15 Mar 2020 23:13:37 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/port-targetport-nodeport-in-kubernetes/</guid>
      <description>원문: https://matthewpalmer.net/kubernetes-app-developer/articles/kubernetes-ports-targetport-nodeport-service.html
쿠버네티스의 port declaration 필드에는 여러가지가 있다. 각 type에 대해 빠르게 살펴보고 YAML에서 각각 어떤 의미를 가지고 있는지 알아보도록 하자.
Pod ports list pod.spec.containers[].ports로 정의된 이 배열은 container가 노출하고 있는 포트의 리스트를 나타낸다. 이 리스트를 꼭 작성해야할 필요는 없다. 리스트가 비어있다고 하더라도 container가 포트를 listening하고 있는 한 여전히 네트워크 접속이 가능하다. 이는 단순히 쿠버네티스에게 추가적인 정보를 줄 뿐이다.
 List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational.</description>
    </item>
    
    <item>
      <title>Stern을 이용하여 여러 pod의 log를 한번에 확인하기</title>
      <link>http://kimmj.github.io/kubernetes/stern/</link>
      <pubDate>Mon, 24 Feb 2020 23:28:01 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/stern/</guid>
      <description>Kubernetes에서의 trouble shooting kubernetes 환경에서 어떤 문제가 발생하면 다음과 같은 flow로 확인을 해보면 됩니다.
 kubectl get pods -o yaml로 yaml을 확인하기 kubectl describe pods로 pod에 대한 설명 확인하기 kubectl describe deployments(statefulset, daemonset)으로 확인하기 kubectl logs로 로그 확인하기  보통 kubernetes 리소스의 부족과 같은 kubernetes단의 문제는 1~3을 확인하면 전부 문제점을 찾을 수 있습니다. 그러나 어플리케이션의 직접적인 원인을 알아보기 위해서는 log를 확인해야 합니다.
하지만 kubectl의 logs에는 한가지 한계점이 있는데, 바로 단일 container에 대해서만 log 확인이 가능하다는 점입니다.</description>
    </item>
    
    <item>
      <title>Pods</title>
      <link>http://kimmj.github.io/kubernetes/concepts/pods/</link>
      <pubDate>Mon, 03 Feb 2020 14:03:50 +0900</pubDate>
      
      <guid>http://kimmj.github.io/kubernetes/concepts/pods/</guid>
      <description>Pod Overview Pod의 이해 Pod는 Kubernetes에서 가장 작은 배포 오브젝트이며 쿠버네티스에서 관리하는 최소 관리 단위입니다. Pod는 cluster 안에서 실행중인 어떤 프로세스를 의미합니다. application container, 스토리지 리소스, 유일한 network ip, container가 어떻게 실행할지를 캡슐화한 것입니다.
각각의 Pod는 주어진 application에서 단일 인스턴스를 수행합니다. 즉, 한가지 역할을 맡고 있다고 생각하시면 됩니다.. 따라서 application을 수직확장하고 싶다면 각 인스턴스에 대해 여러 Pod를 생성하면 된다. 그러면 동일한 역할을 하는 Pod가 늘어나니, 병렬적으로 처리가 가능할 것입니다.
Pod는 서비스 중에서 서로 연관성이 높은 프로세스를 지원하기 위해 디자인되었습니다.</description>
    </item>
    
  </channel>
</rss>